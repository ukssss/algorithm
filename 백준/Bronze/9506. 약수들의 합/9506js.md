# [Bronze I] 약수들의 합 - 9506

[문제 링크](https://www.acmicpc.net/problem/9506)

### 성능 요약

메모리: 9968 KB, 시간: 176 ms

## 목차

- [🤔 문제 풀이](#문제-풀이)
  - [😮 문제를 이해하기](#문제를-이해하기)
  - [✍🏻 이해한 것을 나의 언어로 써보기](#이해한-것을-나의-언어로-써보기)
  - [👨🏻‍💻 구현 및 풀이](#구현-및-풀이)
  - [🫢 배운점](#배운점)

## 문제 풀이

### 문제를 이해하기

어떤 숫자 n이 자신을 제외한 모든 약수들의 합과 같으면, 그 수를 완전수라 한다.

약수를 구한 후, 해당 약수를 모두 더했을 때 n과 같을 경우 약수들을 오름차순으로 나열하고, 그렇지 않을 경우 n is NOT perfect를 출력시킨다.

### 이해한 것을 나의 언어로 써보기

n의 약수 구해서 이를 배열에 담은 후 자신을 제외한 모든 약수들의 합과 같은지 조건문을 생성한다.

조건문이 참일 경우 약수들을 오름차순으로 나열한 출력문을 만들어주고, 그렇지 않을 경우 n is NOT perfect 문장을 출력해준다.

오름차순 정렬은 sort()로 구현, 문장형식은 "+", "=" 를 조건에 맞게 추가하는 식으로 진행해야 할 듯 싶다.

### 구현 및 풀이

입력에서 `2 < n < 100000` 조건이 있어 `filter()`를 사용하여 2보다 큰 수만 배열에 담을 수 있도록 초기에 정렬을 했다.

해당 배열에서 테스트케이스를 한줄씩 뽑아내기 위해 반복문을 사용했으며, 단계별로 약수를 담을 배열을 만들어 주었고, 테스트케이스보다 작은 약수를 구하기 위해 반복문을 이용해 약수를 배열에 담아내는 식으로 구현했다.

그리고 완전수인지 판단하기 위해 `reduce()`를 사용해 약수들의 합을 구했고 이를 테스트케이스 값과 비교를 하는 삼항연산자를 만들었다. 만족할 경우와 그렇지 않을 경우에 맞게 출력문을 달리하였다.

```javascript
const list = require('fs')
  .readFileSync('/dev/stdin')
  .toString()
  .trim()
  .split('\n')
  .map(Number)
  .filter((el) => el > 2);

for (let i = 0; i < list.length; i++) {
  let yaksu = [];
  let input = list[i];

  for (let j = 1; j < input; j++) {
    if (input % j === 0) {
      yaksu.push(j);
    }
  }

  let result = yaksu.reduce((sum, currValue) => {
    return sum + currValue;
  }, 0);

  input === result ? console.log(input + ' = ' + yaksu.join(' + ')) : console.log(input + ' is NOT perfect.');
}
```

### 배운점

문제를 다 풀고 정리를 하는 중에 `입력의 마지막엔 -1이 주어진다` 라는 문장을 지금 보았다.

이걸 일찍 보았다면 그냥 해당 배열에서 마지막꺼만 검사를 안해도 되게 설계를 할 수 있었다.

_오늘도 문제를 꼼꼼히 봐야겠다는 생각을 하였다._
