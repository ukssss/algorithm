# [Bronze I] 부녀회장이 될테야 - 2775

[문제 링크](https://www.acmicpc.net/problem/2775)

### 성능 요약

메모리: 10052 KB, 시간: 132 ms

### 분류

다이나믹 프로그래밍(dp), 구현(implementation), 수학(math)

### 문제 설명

<p>평소 반상회에 참석하는 것을 좋아하는 주희는 이번 기회에 부녀회장이 되고 싶어 각 층의 사람들을 불러 모아 반상회를 주최하려고 한다.</p>

<p>이 아파트에 거주를 하려면 조건이 있는데, “a층의 b호에 살려면 자신의 아래(a-1)층의 1호부터 b호까지 사람들의 수의 합만큼 사람들을 데려와 살아야 한다” 는 계약 조항을 꼭 지키고 들어와야 한다.</p>

<p>아파트에 비어있는 집은 없고 모든 거주민들이 이 계약 조건을 지키고 왔다고 가정했을 때, 주어지는 양의 정수 k와 n에 대해 k층에 n호에는 몇 명이 살고 있는지 출력하라. 단, 아파트에는 0층부터 있고 각층에는 1호부터 있으며, 0층의 i호에는 i명이 산다.</p>

### 입력

 <p>첫 번째 줄에 Test case의 수 T가 주어진다. 그리고 각각의 케이스마다 입력으로 첫 번째 줄에 정수 k, 두 번째 줄에 정수 n이 주어진다</p>

### 출력

 <p>각각의 Test case에 대해서 해당 집에 거주민 수를 출력하라.</p>

### 풀이

일단 처음에 나는 입력값이 무슨 뜻인지 이해를 하지 못하여서 시간이 꽤 걸렸던 문제였다. 알고보니 세로로 입력된 값 중, 1 번째 줄의 값이 Test case 의 수 **T**, 그 이후 각각의 케이스마다 입력값이 들어오는 것으로 첫 번째 줄이 층을 의미하는 정수 **k**, 두 번째 줄에 호수를 나타내는 정수 **n** 이 들어오는 것이다.

즉 예제 입력 1 에서는

```bash
2
1
3
2
3
```

순서로 입력이 되는데, Test case t 는 2 이고, 첫 번째 Test case 는 k = 1, n = 3 이 되는 것이고, 두 번째 Test case 는 k = 2, n = 3 이 되는 것이다.

배열을 만들어서 해당 문제를 접근하였는데, 처음에 길이가 k + 1 인 배열을 생성하고, 0 으로 꽉찬 길이가 n + 1 인 배열로 채워진 배열을 만들었다.

```js
// 길이가 k + 1 인 배열을 생성 후, 배열안에 0 으로 꽉채운 길이가 n + 1 인 배열 생성
const apt = Array.from(Array(k + 1), () => Array(n + 1).fill(0));
```

그 후 0 층 인 경우를 먼저 값을 채워주고, 1 ~ k 층 까지 값을 채워주는 방식으로 문제를 해결하였다.
0 층인 경우는 i 호에는 i 명이 살기에 for 문의 변수를 값으로 할당하여 이를 채워넣었으며, 1 ~ k 층의 경우는 처음에는 어떻게 값을 채워넣을 지 고민하다 하나 하나 호수 마다 인원수를 계산하다가 다음과 같은 공식을 찾게 되었다.

| 층/호 | 1   | 2             | 3               |
| ----- | --- | ------------- | --------------- |
| 0층   | 1   | 2             | 3               |
| 1층   | 1   | 3             | 6               |
| 2층   | 1   | 4             | 10              |
| 3층   | 1   | 5             | 15              |
| 4층   | 1   | 1 + 5 = **6** | 6 + 15 = **21** |

즉 해당 집의 거주민 수는 다음과 같은 공식으로 유도할 수 있었다.

```js
// f 층 j 호 입주민의 수는 f - 1 층의 j 호의 입주민 수에 f 층의 j - 1 호 입주민 수를 더한 것과 같다.
apt[f][j] = apt[f - 1][j] + apt[f][j - 1];
```

이러한 공식을 사용해서 조건에 맞는 집을 선택해서 해당 집에 거주민 수를 출력할 수 있었다.
