# [Silver III] Four Squares - 17626

[문제 링크](https://www.acmicpc.net/problem/17626)

### 성능 요약

메모리: 10020 KB, 시간: 248 ms

### 분류

브루트포스 알고리즘, 다이나믹 프로그래밍

## 목차

-   [🤔 접근법](#접근법)
-   [👨🏻‍💻 구현 및 풀이](#구현-및-풀이)
-   [🫢 배운점](#배운점)

### 접근법

DP(Dynamic Programming) 과 브루트포스 알고리즘을 활용한 문제였다.

제곱수로만 N을 만들 때, 최소한의 개수를 출력하는 문제인데 문제를 읽어보면 모든 자연수는 넷 혹은 그 이하의 제곱수의 합으로 표현할 수 있다고 증명하였다. 그래서 자연수 n이 주어질 때, n을 최소 개수의 제곱수 합으로 표현하는 코드를 만들어라는 문제였다.

처음에는 브루트포스 알고리즘으로 하나씩 구하면 되겠다 싶었는데, 시간 제한이 0.5초 인 것을 보고 이걸 브루트포스 알고리즘을 사용하면 시간복잡도가 O(n^2)이 나와 시간 초과라는 결과가 나올 것이 뻔했다.

그래서 연산을 최대한 줄일 수 있는 방법이 필요하다 싶어 이전에 연산했던 값을 이용하면 연산 횟수를 줄일 수 있겠다라는 접근을 하여 DP를 활용하여 풀어보았다.

dp[N]은 더해서 N이 되는 제곱수의 개수의 최솟값이다. 즉 임의의 자연수 n(N <= n^2)에 대해서 N = n^2라면 dp[N] = 1 이다.

N은 제곱수들의 합이므로, dp[N] = dp[n^2] + dp[N - n^2] = dp[N - n^2] + 1 이라는 식을 유도할 수 있다.

그러나 어떤 자연수 n을 골라야 dp[N]의 최솟값을 구할 수 있는지 알 수 없기 때문에 N <= n^2인 모든 n에 대해서 dp[N - n^2]을 구해서 최솟값을 갱신한다. 그리고 해당 값에 1을 더하면 dp[N]의 최솟값을 구할 수 있다.

e.g. N = 27

N <= n ^ 2

-   n = 2
    dp[27] = dp[4] + dp[23] = dp[23] + 1 = 5

-   n = 3
    dp[27] = dp[9] + dp[18] = dp[18] + 1 = 3

-   n = 4
    dp[27] = dp[16] + dp[11] = dp[11] + 1 = 4

-   n = 5
    dp[27] = dp[25] + dp[2] = dp[2] + 1 = 3

=> 3

### 구현 및 풀이

```javascript
const input = +require('fs').readFileSync('/dev/stdin').toString().trim();

function solution(n) {
    const dp = new Array(n + 1).fill(0);
    dp[1] = 1;

    for (let i = 2; i <= n; i++) {
        let min = 4;
        for (let j = 1; j * j <= i; j++) {
            min = Math.min(min, dp[i - j * j]);
        }
        dp[i] = min + 1;
    }

    return dp[n];
}

const ans = solution(input);
console.log(ans);
```

### 배운점

처음으로 dp를 활용하여 문제를 풀어보았다. 이해를 하는데 상당한 시간을 할애했다.

보다 효율적인 코드를 구상할 수 있다는 점에서 매력적이었다.
